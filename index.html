<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>千里之行，始于足下</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="千里之行，始于足下">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="千里之行，始于足下">
<meta property="article:author" content="ink">
<meta property="article:tag" content="Linux AI 算法">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="千里之行，始于足下" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">千里之行，始于足下</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">黄政的个人技术博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-computer-system/gcc-compile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/10/computer-system/gcc-compile/" class="article-date">
  <time datetime="2021-10-10T02:42:22.610Z" itemprop="datePublished">2021-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/10/computer-system/gcc-compile/">操作系统：hello world 编译过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天通过hello.c的例子，给大家讲述一下gcc的编译过程，</p>
<h1 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h1><p>插入图片 Figure 1.3 The compilation system.</p>
<h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><h2 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">预处理器(cpp)就是根据字符#开头指令，对原始的c程序进行修改。C预处理器就是C、Objective-C、C++等计算机编程语言的宏处理器。预处理器为这些编程语言提供头文件的包含、宏拓展、条件编译和行控制等功能。在大多数C语言的实现中，预处理器是编译器在编译代码过程中，第一个调用的程序。</span><br><span class="line">  </span><br><span class="line">预处理器指令语言与C语言的语法关系不大，因此有时被用来处理其他类型的文本文件。C预处理器不是编译器的一部分，而是编译过程中的一个单独步骤。简单地说，C预处理器只是一个文本替换工具，它指示编译器在实际编译之前进行必要的预处理。我们将C预处理器称为CPP。所有预处理器命令都以哈希符号(#)开头。它必须是第一个非空白字符，为了可读性，预处理器指令应该从第一列开始。</span><br></pre></td></tr></table></figure>

<p>下面的部分列出了所有重要的预处理器指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>#define</strong></td>
<td>替代一个预处理器宏</td>
</tr>
<tr>
<td><strong>#include</strong></td>
<td>插入另外一个文件的特定头部内容</td>
</tr>
<tr>
<td><strong>#undef</strong></td>
<td>取消定义预处理器宏.</td>
</tr>
<tr>
<td><strong>#ifdef</strong></td>
<td>如果宏被定义，返回true</td>
</tr>
<tr>
<td><strong>#ifndef</strong></td>
<td>Returns true if this macro is not defined.如果宏未被定义，返回true</td>
</tr>
<tr>
<td><strong>#if</strong></td>
<td>Tests if a compile time condition is true.测试编译时，条件是否为真</td>
</tr>
<tr>
<td><strong>#else</strong></td>
<td>#if 条件之后的选择</td>
</tr>
<tr>
<td><strong>#elif</strong></td>
<td>else 和 #if的语法</td>
</tr>
<tr>
<td><strong>#endif</strong></td>
<td>预处理条件的结束</td>
</tr>
<tr>
<td><strong>#error</strong></td>
<td>打印stderr的错误信息</td>
</tr>
<tr>
<td><strong>#pragma</strong></td>
<td>使用标准化方法向编译器发出特殊命令。</td>
</tr>
</tbody></table>
<pre><code>C预处理器是在编译程序之前使用的。它预扫描源代码，以完成包括头文件，宏扩展，条件编译，行控制等功能。对于测试代码，预处理器只处理头文件。要获得预处理器的输出，使用命令**gcc -E hello.c -o hello.i**。</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tips:</span><br><span class="line">There are many such formats in hello.i, # line file name flags, which means that the following line is generated by the line of file name. Among them, flags have four values: 1, 2, 3 and 4</span><br><span class="line"></span><br><span class="line">1 represents the beginning of a new document</span><br><span class="line">2 represents the return of a file</span><br><span class="line">3 means that the following text comes from the system header file, so some warnings can be filtered out</span><br><span class="line">4 means that the following text should be included in the extern C block. According to the prompt, there is size on line 212 in the stddef.h file_ Macro definition of T.</span><br></pre></td></tr></table></figure>


<h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编译过程：编译就是将一种编程语言源码，翻译成汇编语言。GCC编译器就是将C语言源码翻译成汇编代码，汇编语言为不同高级语言的编译器提供了通用的输出语言。</span><br><span class="line">经过上述预处理阶段，我们已经将hello.c的源代码，处理成了hello.i文件，现在通过执行命令**gcc -S hello.i -o hello.s**转换hello.i为hello.s（汇编代码）。</span><br></pre></td></tr></table></figure>

<p><strong>汇编代码hello.s</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        .file   &quot;hello.c&quot;</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;hello world&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        movl    $.LC0, %edi</span><br><span class="line">        call    puts</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        popq    %rbp</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  &quot;GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>

<h2 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a>汇编阶段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">汇编的过程，就是将汇编语言的源代码转换成可执行的机器代码。通常来说，目标文件至少包含两个部分：代码段和数据段。</span><br><span class="line">代码段：包含程序指令，通常是可读、可执行、但是不可写；数据段是用来存储程序中用到的各种类型的全局变量和静态数据，通常是可读、可写、可执行的。</span><br><span class="line">通过执行命令**gcc -o hello.o -c hello.c.**获取汇编器的输出结果，因为hello.o是一个二进制文件，文本阅读的时是乱码，所以我们使用objdump针对二进制文件进行反汇编，再阅读反汇编代码。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@ink The-compilation-system]# objdump -d hello.o &gt;&gt; hello.o.dump</span><br><span class="line">[root@ink The-compilation-system]# ls -l</span><br><span class="line">total 36</span><br><span class="line">-rw-r--r-- 1 root root    78 Sep 26 19:30 hello.c</span><br><span class="line">-rw-r--r-- 1 root root 16879 Sep 26 20:07 hello.i</span><br><span class="line">-rw-r--r-- 1 root root  1496 Sep 26 20:20 hello.o</span><br><span class="line">-rw-r--r-- 1 root root   396 Sep 26 20:20 hello.o.dump</span><br><span class="line">-rw-r--r-- 1 root root   448 Sep 26 20:13 hello.s</span><br><span class="line">[root@ink The-compilation-system]# cat hello.o.dump</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   55                      push   %rbp</span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   4:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">   9:   e8 00 00 00 00          callq  e &lt;main+0xe&gt;</span><br><span class="line">   e:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  13:   5d                      pop    %rbp</span><br><span class="line">  14:   c3                      retq</span><br></pre></td></tr></table></figure>


<p>*<em>objdump -h *</em>命令可以获取二进制文件每个段的头部信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@ink The-compilation-system]# objdump -h hello.o</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000015  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  00000055  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000055  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       0000000c  0000000000000000  0000000000000000  00000055  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000002e  0000000000000000  0000000000000000  00000061  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000008f  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .eh_frame     00000038  0000000000000000  0000000000000000  00000090  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure>

<h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h2><pre><code>链接的过程是将编译器或汇编器生成的一个或多个目标文件链接库(静态库或动态库)转换为可执行文件。静态库将与程序集生成的对象文件链接，并打包到可执行文件[静态链接]。它与函数库的链接在编译期间完成。动态库不会在程序编译时链接到可执行文件，而是在程序运行时加载。如果不同的应用程序调用相同的库，它们只需要内存中共享库的一个实例
可以通过执行**ldd hello**命令查看hello程序依赖的函数库。</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ink The-compilation-system]# ldd hello</span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffc7e78e000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fcb4fa45000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fcb4fe12000)</span><br></pre></td></tr></table></figure>

<h1 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h1><ul>
<li>O1 </li>
</ul>
<h1 id="常见的安全编译选项"><a href="#常见的安全编译选项" class="headerlink" title="常见的安全编译选项"></a>常见的安全编译选项</h1><h2 id="ASLR（地址空间布局随机化）"><a href="#ASLR（地址空间布局随机化）" class="headerlink" title="ASLR（地址空间布局随机化）"></a>ASLR（地址空间布局随机化）</h2><p><a href="https://wiki.ubuntu.com/Security/Features#stack-protector" target="_blank" rel="noopener">https://wiki.ubuntu.com/Security/Features#stack-protector</a><br><a href="https://www.jianshu.com/p/859de634ded8" target="_blank" rel="noopener">https://www.jianshu.com/p/859de634ded8</a></p>
<h2 id="NX（堆栈不可执行）"><a href="#NX（堆栈不可执行）" class="headerlink" title="NX（堆栈不可执行）"></a>NX（堆栈不可执行）</h2><p>-Wl,-z,noexecstack</p>
<h2 id="SP-栈保护"><a href="#SP-栈保护" class="headerlink" title="SP(栈保护)"></a>SP(栈保护)</h2><p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.9.4/gcc/Optimize-Options.html#Optimize-Options" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc-4.9.4/gcc/Optimize-Options.html#Optimize-Options</a><br><a href="https://arxiv.org/pdf/1909.05747.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1909.05747.pdf</a></p>
<p>-fstack-protector<br>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call alloca, and functions with buffers larger than 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits.<br>-fstack-protector-all<br>Like -fstack-protector except that all functions are protected.<br>-fstack-protector-strong<br>Like -fstack-protector but includes additional functions to be protected — those that have local array definitions, or have references to local frame addresses.</p>
<p>链接阶段加上：-fstack-protector</p>
<p><strong>实战用例</strong></p>
<h2 id="RELRO（只读重定位）"><a href="#RELRO（只读重定位）" class="headerlink" title="RELRO（只读重定位）"></a>RELRO（只读重定位）</h2><p><a href="https://www.leviathansecurity.com/blog/aslr-protection-for-statically-linked-executables" target="_blank" rel="noopener">https://www.leviathansecurity.com/blog/aslr-protection-for-statically-linked-executables</a><br><a href="https://www.redhat.com/zh/blog/hardening-elf-binaries-using-relocation-read-only-relro" target="_blank" rel="noopener">https://www.redhat.com/zh/blog/hardening-elf-binaries-using-relocation-read-only-relro</a></p>
<h2 id="PIC（位置无关代码）"><a href="#PIC（位置无关代码）" class="headerlink" title="PIC（位置无关代码）"></a>PIC（位置无关代码）</h2><p><a href="https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Code-Gen-Options.html#Code-Gen-Options" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Code-Gen-Options.html#Code-Gen-Options</a></p>
<h2 id="PIE（位置无关可执行文件）"><a href="#PIE（位置无关可执行文件）" class="headerlink" title="PIE（位置无关可执行文件）"></a>PIE（位置无关可执行文件）</h2><p><a href="https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Code-Gen-Options.html#Code-Gen-Options" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Code-Gen-Options.html#Code-Gen-Options</a></p>
<h2 id="RPATH（动态库搜索路径）"><a href="#RPATH（动态库搜索路径）" class="headerlink" title="RPATH（动态库搜索路径）"></a>RPATH（动态库搜索路径）</h2><p><a href="https://sourceware.org/binutils/docs/ld/Options.html#Options" target="_blank" rel="noopener">https://sourceware.org/binutils/docs/ld/Options.html#Options</a></p>
<h2 id="Strip"><a href="#Strip" class="headerlink" title="Strip"></a>Strip</h2><p><a href="https://sourceware.org/binutils/docs/ld/Options.html#Options" target="_blank" rel="noopener">https://sourceware.org/binutils/docs/ld/Options.html#Options</a></p>
<h2 id="FS"><a href="#FS" class="headerlink" title="FS"></a>FS</h2><p><a href="https://access.redhat.com/blogs/766093/posts/3606481" target="_blank" rel="noopener">https://access.redhat.com/blogs/766093/posts/3606481</a></p>
<h2 id="Ftrapv"><a href="#Ftrapv" class="headerlink" title="Ftrapv"></a>Ftrapv</h2><p><a href="https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Code-Gen-Options.html#Code-Gen-Options" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Code-Gen-Options.html#Code-Gen-Options</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《深入理解计算机操作系统》</p>
<p><a href="https://www.fatalerrors.org/a/four-steps-of-c-programming.html" target="_blank" rel="noopener">Four steps of C programming</a></p>
<p><a href="https://www.tutorialspoint.com/cprogramming/c_preprocessors.htm" target="_blank" rel="noopener">C - Preprocessors</a></p>
<p><a href="https://en.wikipedia.org/wiki/C_preprocessor" target="_blank" rel="noopener">C preprocessor</a></p>
<p><a href="https://www.geeksforgeeks.org/preprocessor-works-c/" target="_blank" rel="noopener">How a Preprocessor works in C?</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/10/10/computer-system/gcc-compile/" data-id="ckxmr9pc60000287c134mblua" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/Linux_capabilities" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/02/Linux/Linux_capabilities/" class="article-date">
  <time datetime="2021-08-02T14:19:26.367Z" itemprop="datePublished">2021-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/02/Linux/Linux_capabilities/">Linux 如何使用capabilities机制实现进程权限管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="systemd机制"><a href="#systemd机制" class="headerlink" title="systemd机制"></a>systemd机制</h1><p>systemd是linux操作系统的系统和服务管理进程。系统启动的时候，作为1号进程启动，进行系统初始化和拉起用户定义的其他服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root         1  0.5  0.3  43396  3696 ?        Ss   10:14   0:00 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br></pre></td></tr></table></figure>

<p>systemd进程通常不会被用户调用，而是由/sbin/init软链接，在最开始的启动过程拉起。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ink ~]# ls -l /sbin/init</span><br><span class="line">lrwxrwxrwx 1 root root 22 Jul 11  2019 /sbin/init -&gt; ../lib/systemd/systemd</span><br></pre></td></tr></table></figure>

<h2 id="systemd-添加nginx服务实践"><a href="#systemd-添加nginx服务实践" class="headerlink" title="systemd 添加nginx服务实践"></a>systemd 添加nginx服务实践</h2><ol>
<li><p>添加service</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@ink system]# cat /etc/systemd/system/nginx.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx</span><br><span class="line">After=aliyun.target</span><br><span class="line">Wants=aliyun.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=1min</span><br><span class="line">StartLimitInterval=36000</span><br><span class="line">StartLimitBurst=5</span><br><span class="line">KillMode=process</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>systemd load新的服务文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统启动过程中拉起服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ink system]# systemctl enable nginx.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /etc/systemd/system/nginx.service.</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动拉起服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@ink system]# ps auxf | grep nginx | grep -v grep</span><br><span class="line">[root@ink system]# service nginx start</span><br><span class="line">Redirecting to /bin/systemctl start nginx.service</span><br><span class="line">[root@ink system]# ps auxf | grep nginx | grep -v grep</span><br><span class="line">root      3796  0.0  0.0  25004   768 ?        Ss   11:06   0:00 nginx: master process /usr/local/nginx/sbin/nginx</span><br><span class="line">nobody    3797  0.0  0.1  25420  1484 ?        S    11:06   0:00  \_ nginx: worker process</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@ink system]# systemctl enable nginx.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /etc/systemd/system/nginx.service.</span><br><span class="line">[root@ink system]# systemctl status nginx.service</span><br><span class="line">● nginx.service - nginx</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/nginx.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: inactive (dead)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务启动的日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ink system]# journalctl -u nginx.service</span><br><span class="line">-- Logs begin at Thu 2019-07-11 11:10:15 CST, end at Fri 2021-07-23 11:40:01 CST. --</span><br><span class="line">-- Reboot --</span><br><span class="line">Jul 23 11:16:41 ink systemd[1]: Started nginx.</span><br><span class="line">Jul 23 11:25:48 ink systemd[1]: Started nginx.</span><br><span class="line">-- Reboot --</span><br><span class="line">Jul 23 11:30:43 ink systemd[1]: Started nginx.</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><a href="https://man7.org/linux/man-pages/man1/systemd.1.html" target="_blank" rel="noopener">systemd(1) — Linux manual page</a></p>
<p><a href="https://www.digitalocean.com/community/tutorials/how-to-use-systemctl-to-manage-systemd-services-and-units" target="_blank" rel="noopener">How To Use Systemctl to Manage Systemd Services and Units</a></p>
<h1 id="进程权限管理"><a href="#进程权限管理" class="headerlink" title="进程权限管理"></a>进程权限管理</h1><h2 id="用户-组"><a href="#用户-组" class="headerlink" title="用户/组"></a>用户/组</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护</p>
<ol>
<li><p>Linux 查看所有用户</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ink system]# cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br></pre></td></tr></table></figure>
</li>
<li><p>Linux 查看用户组</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@ink system]# cat /etc/group</span><br><span class="line">root:x:0:</span><br><span class="line">bin:x:1:</span><br><span class="line">daemon:x:2:</span><br><span class="line">sys:x:3:</span><br><span class="line">adm:x:4:</span><br></pre></td></tr></table></figure></li>
<li><p>getent<br>linux中用于提供查询用户信息的命令</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getent passwd</span><br><span class="line">getent group</span><br><span class="line">getent group daemon</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Linux新增用户<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@ink system]# useradd test -U -p 123</span><br><span class="line">[root@ink system]# su test</span><br><span class="line">[test@ink system]$ ls -l</span><br><span class="line">total 40</span><br><span class="line">-rw-r--r--  1 root root  492 Jul 21 01:17 aliyun.service</span><br><span class="line">-rw-r--r--  1 root root  214 Jul 21 01:17 AssistDaemon.service</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 11  2019 basic.target.wants</span><br><span class="line">lrwxrwxrwx. 1 root root   37 Jul 11  2019 default.target -&gt; /lib/systemd/system/multi-user.target</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 11  2019 default.target.wants</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 11  2019 getty.target.wants</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 11  2019 local-fs.target.wants</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 23 11:15 multi-user.target.wants</span><br><span class="line">-rw-r--r--  1 root root  248 Jul 23 11:28 nginx.service</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 11  2019 sysinit.target.wants</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 11  2019 system-update.target.wants</span><br><span class="line">[test@ink system]$ mv nginx.service nginx.service.back</span><br><span class="line">mv: cannot move ‘nginx.service’ to ‘nginx.service.back’: Permission denied</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>超级用户：root id 为0，有着系统中最大的权限，可以访问系统中的任何文件，一般使用root账号来执行系统管理的任务。上面的例子可以看出普通用户test，无法修改nginx.service。</p>
<h2 id="进程权限"><a href="#进程权限" class="headerlink" title="进程权限"></a>进程权限</h2><ol>
<li><p>编写demo进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    daemon(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc test.c -o demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>root账户拉起test进程，并查看进程的用户和用户组，都为root</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ink code]# ./demo</span><br><span class="line">[root@ink code]# ps -eo pid,user,group,args | grep demo | grep -v grep</span><br><span class="line"> 1609 root     root     ./demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换test用户，拉起进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ink code]# kill -9 $(pidof demo)</span><br><span class="line">[root@ink code]# su test</span><br><span class="line">[test@ink code]$ ./demo</span><br><span class="line">[test@ink code]$ ps -eo pid,user,group,args | grep demo | grep -v grep</span><br><span class="line"> 1702 test     test     ./demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件的权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ink test]# ls -l test</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 26 10:13 test</span><br><span class="line"></span><br><span class="line">[root@ink test]# chmod 754 ./test</span><br><span class="line">[root@ink test]# ls -l</span><br><span class="line">total 0</span><br><span class="line">-rwxr-xr-- 1 root root 0 Jul 26 10:13 test</span><br></pre></td></tr></table></figure>

</li>
</ol>
<table>
<thead>
<tr>
<th>-rwxrwxrwx</th>
<th>详解</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>第一个字段 -代表文件，d代表目录，l代表链接，c代表字符型设备，b代表块设备，n代表网络设备</td>
</tr>
<tr>
<td>rwx</td>
<td>代表所有者的权限：这个文件对应就是root  可读、可写、可执行</td>
</tr>
<tr>
<td>r-x</td>
<td>代表同组其他用户的权限：可读、不可写、可执行</td>
</tr>
<tr>
<td>r–</td>
<td>代表其他用户的其他权限：可读、不可写、不可执行</td>
</tr>
</tbody></table>
<h1 id="capabilities-机制"><a href="#capabilities-机制" class="headerlink" title="capabilities  机制"></a>capabilities  机制</h1><p><strong>问题：</strong></p>
<p><strong>1. 编写的daemon不需要root用户的所有权限，独立账号运行安全性更高</strong></p>
<p><strong>2. 更改为普通用户拉起daemon，需要读取部分root权限才可以正常运行业务</strong></p>
<p><strong>解决方法：</strong></p>
<p><strong>1. 使用systemd service 管理，指定用户和用户启动进程</strong></p>
<p><strong>2. 使用linux capabilitie 管理进程的权限，保障最小权限正常运行业务</strong></p>
        
          <p class="article-more-link">
            <a href="/2021/08/02/Linux/Linux_capabilities/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/08/02/Linux/Linux_capabilities/" data-id="ckxmr9pcm0003287chp1wf1fl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-algorithm/sort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/14/algorithm/sort/" class="article-date">
  <time datetime="2020-10-14T12:40:55.550Z" itemprop="datePublished">2020-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/14/algorithm/sort/">【算法】常见排序算法分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="冒泡排序思想"><a href="#冒泡排序思想" class="headerlink" title="冒泡排序思想"></a>冒泡排序思想</h2><ol>
<li>循环遍历输入的数组（这层循环确定已排序区间和未排序区间）</li>
<li>内部循环遍历未排序的区间（这层进行冒泡比较和调换）</li>
<li>比较内部循环相邻两个数据是否满足比较条件（例如小于），不满足就进行交换，再接着向后遍历，一直到遍历完未排序区间</li>
<li>优化点：定义一个交换标记，有交换时置位true，未有交换时提前退出循环</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* first, <span class="keyword">int</span>* second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = *first;</span><br><span class="line">        *first = *second;</span><br><span class="line">        *second = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> [] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i <span class="number">-1</span>; ++j) &#123; <span class="comment">//j &lt; n-i-1是关键，j+1就代表着未冒泡的最后一个数</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(&amp;a[j], &amp;a[j+<span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123; <span class="comment">//整个过程没有一次数据交换，就可以退出，提前结束排序了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序算法分析"><a href="#冒泡排序算法分析" class="headerlink" title="冒泡排序算法分析"></a>冒泡排序算法分析</h2><ol>
<li>原地排序算法（只涉及原内存空间的排序，空间复杂度为O(1)）</li>
<li>相邻两个数据==时不交换，是稳定排序算法</li>
<li>时间复杂度：最好O(n) 一轮循环直接结束，无需进行交换；最坏O(n^2) 要进行排序的数据时逆序的；平均O(n^2)涉及两层n常量的循环</li>
</ol>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="插入排序思想"><a href="#插入排序思想" class="headerlink" title="插入排序思想"></a>插入排序思想</h2><ol>
<li>循环遍历输入的数组（这层循环确定已排序区间和未排序区间），拿到当前需要进行插入排序的值</li>
<li>内层循环递减遍历已排序区间的数组，与当前需要插入的值进行比较，与插入值相比满足比较条件的向后移，一直找到插入的位置break</li>
<li>break之后的索引+1（因为偏移到了未满足条件的前一个值了）即是当前值正确插入的位置<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;   <span class="comment">//遍历下标从1开始</span></span><br><span class="line">        <span class="keyword">int</span> val = a[i];</span><br><span class="line">        <span class="keyword">int</span> j = i <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) </span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; val) &#123;</span><br><span class="line">                a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;      <span class="comment">//这里需要break; 不然索引不对</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a[j+<span class="number">1</span>] = val;       <span class="comment">//这里应该是j+1，因为已经向前偏移一位了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="插入排序分析"><a href="#插入排序分析" class="headerlink" title="插入排序分析"></a>插入排序分析</h2><ol>
<li>原地排序（只涉及原内存空间的排序，空间复杂度为O(1)）</li>
<li>当前需要插入的值与比较值==时即break跳出循环，这样可以保证两个相同的值在数组中的位置不变，是稳定排序算法</li>
<li>时间复杂度：最好O(n)，最坏O(n^2)，平均 O(n^2)</li>
</ol>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="归并排序思想"><a href="#归并排序思想" class="headerlink" title="归并排序思想"></a>归并排序思想</h2><ol>
<li>归并排序用的是分治思想，将1个大问题递归分解小问题，处理完小问题之后再进行合并，最终处理完整个问题</li>
<li>归并排序数组：将数组递归平分成2个小数组，针对前后两部分进行排序，排序完再讲前后两部分进行合并</li>
<li>归并分解公式 merge_sort(array, p, r) = merge_sort(array, p, (p+r)/2) + merge_sort(array, (p+r)/2 + 1, r)</li>
<li>递归终止条件：p &gt;= r</li>
<li>归并排序的重点在于合并过程merge(array, p, q)：<br>. 1）根据传入p,q，分别开辟前后两个子数组L和R<br>. 2）分别存入array从p, (p+r)/2和(p+r)/2+1,r的数据<br>. 3) 循环比较L和R的数据，将满足条件的值放在：array从p索引开始的位置，依次向后递增<br>. 4) L和R有一个数组的数据被放空当前循环结束，然后将剩余未遍历完的数据放入array递增的后续位置</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (p+q)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> nl = m-p+<span class="number">1</span>; <span class="comment">//左区间数组的大小（因为p,q都是元素下标，所以数组大小要+1）</span></span><br><span class="line">    <span class="keyword">int</span> nr = q-m;   <span class="comment">//右区间数组的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* L = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(nl);  <span class="comment">//应该对L和R进行返回值判断，这里展示算法过程忽略</span></span><br><span class="line">    <span class="keyword">int</span>* R = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(nr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; nl; ++i) &#123;    <span class="comment">//将左右区间的元素存入L和R数组，</span></span><br><span class="line">        L[i] = a[p+i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j &lt; nr; ++j) &#123;</span><br><span class="line">        R[j] = a[m+<span class="number">1</span>+j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    k = p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; nl &amp;&amp; j &lt; nr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;     <span class="comment">//这里按照从小到大进行排序</span></span><br><span class="line">            a[k++] = L[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a[k++] = R[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; nl) &#123;            <span class="comment">//将L或者R数组从未填完的元素填入a数组中</span></span><br><span class="line">        a[k++] = L[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (j &lt; nr) &#123;</span><br><span class="line">        a[k++] = R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    <span class="built_in">free</span>(R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; q) &#123;            <span class="comment">//递归终止条件 p&gt;=q</span></span><br><span class="line">        <span class="keyword">int</span> m = (p+q)/<span class="number">2</span>;</span><br><span class="line">        merge_sort(a, p, m);    <span class="comment">//分成两个子数组进行排序</span></span><br><span class="line">        merge_sort(a, m+<span class="number">1</span>, q);</span><br><span class="line">        merge(a, p, q);     <span class="comment">//合并两个已排序好的子数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序分析"><a href="#归并排序分析" class="headerlink" title="归并排序分析"></a>归并排序分析</h2><ol>
<li>非原地排序算法，merge的过程中开辟了新空间，空间复杂度为O(n)</li>
<li>当L和R子数组值进行比较时，值相同，填入L的值到array，这样可以保证两个相同的值在数组中的位置不变，是稳定排序算法</li>
<li>时间复杂度：归并排序不管数组输入的有序程序是如何，最好，最坏，平均时间复杂度都是O(nlogn)</li>
</ol>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="快排思想"><a href="#快排思想" class="headerlink" title="快排思想"></a>快排思想</h2><ol>
<li>快排利用的也是分治思想</li>
<li>从array的low到high之间选取任意位置一个数组作为分区点(pivot)</li>
<li>遍历array从low到high，将满足比较条件（例如小于）的数据置于左区间，不满足的置于右区间，中间填写pivot的数据</li>
<li>继续递归排序左区间和右区间</li>
<li>递归公式：quick_sort(array, low, high) = quick_sort(array, low, pivot-1) + quick_sort(array, pivot+1, high)</li>
<li>递归终止条件：low &gt;= high</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* first, <span class="keyword">int</span>* second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *first;</span><br><span class="line">    *first = *second;</span><br><span class="line">    *second = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[high];    <span class="comment">//分区点数据取当前数组最后一个元素</span></span><br><span class="line">    <span class="keyword">int</span> i = low - <span class="number">1</span>;        <span class="comment">//已排序区间最后一个元素的索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = low; j &lt; high; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt;= pivot) &#123; <span class="comment">//小于等于pivot的元素都放入已排序区间</span></span><br><span class="line">            i++;</span><br><span class="line">            swap(&amp;a[i], &amp;a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                        </span><br><span class="line">    swap(&amp;a[i+<span class="number">1</span>], &amp;a[high]);  <span class="comment">//分区数据已排序区间（左区间）的下一个位置</span></span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;               <span class="comment">//返回pivot的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(a, low, high);</span><br><span class="line">        quick_sort(a, low, pivot<span class="number">-1</span>);</span><br><span class="line">        quick_sort(a, pivot+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快排分析"><a href="#快排分析" class="headerlink" title="快排分析"></a>快排分析</h2><ol>
<li>原地排序算法</li>
<li>partition过程中涉及交换操作，相同元素的先后顺序可能发生改变，非稳定的排序算法</li>
<li>时间复杂度：平均时间复杂度为O(logn)，极端情况下为O(n^2)</li>
<li>快排的关键在于partition过程，实现了原址重排</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/14/algorithm/sort/" data-id="ckxmr9pcm0002287caz4qfwjc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/Linux_coredump" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/08/Linux/Linux_coredump/" class="article-date">
  <time datetime="2020-08-08T08:16:33.348Z" itemprop="datePublished">2020-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/08/Linux/Linux_coredump/">Linux coredump机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>Linux信号处理机制的一种，收到对应信号，会产生核心存储文件，同时进程终止。core文件会把保存当时进程的内存信息，可以通过gdb进行调试。</p>
<h1 id="默认行为core的信号列表"><a href="#默认行为core的信号列表" class="headerlink" title="默认行为core的信号列表"></a>默认行为core的信号列表</h1><table>
<thead>
<tr>
<th>名称</th>
<th>信号值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIGQUIT</td>
<td>3</td>
<td>终端退出</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>无效的内存引用</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>31</td>
<td>终端退出</td>
</tr>
</tbody></table>
<h1 id="core文件参数设置"><a href="#core文件参数设置" class="headerlink" title="core文件参数设置"></a>core文件参数设置</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/kernel/core_pattern</span><br><span class="line"></span><br><span class="line">默认的配置</span><br><span class="line">[root@localhost ~]# cat /proc/sys/kernel/core_pattern</span><br><span class="line">|/usr/libexec/abrt-hook-ccpp %s %c %p %u %g %t %e</span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">s 造成coredump的信号值</span></span><br><span class="line"><span class="meta">%</span><span class="bash">c 崩溃进程core文件大小的软限制</span></span><br><span class="line"><span class="meta">%</span><span class="bash">p 进程的pid</span></span><br><span class="line"><span class="meta">%</span><span class="bash">u 进程的uid</span></span><br><span class="line"><span class="meta">%</span><span class="bash">g 进程的gid</span></span><br><span class="line"><span class="meta">%</span><span class="bash">t 进程出core的时间</span></span><br><span class="line"><span class="meta">%</span><span class="bash">e  执行出core的命令</span></span><br></pre></td></tr></table></figure>

<p>修改core dump参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&#x2F;root&#x2F;core_dump&#x2F;core-%s-%e-%p-%t&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern</span><br></pre></td></tr></table></figure>

<h1 id="core文件生成限制"><a href="#core文件生成限制" class="headerlink" title="core文件生成限制"></a>core文件生成限制</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 11039</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 65536</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 11039</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<ol>
<li>ulimit -a 或者 unlimit -c可以看到</li>
<li>core file size代表 core文件大小：0代表 core无法生成</li>
<li>core生成，受到 core file size 和file size两个限制</li>
</ol>
<p>修改core文件大小限制为unlimited</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ulimit -c unlimited</span><br><span class="line">[root@localhost ~]# ulimit -c</span><br><span class="line">unlimited</span><br></pre></td></tr></table></figure>

<p>Linux编程中可以使用getrlimit和setrlimit进行设置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br><span class="line">RLIMIT_CORE</span><br><span class="line">     Maximum <span class="built_in">size</span> of core file.  When <span class="number">0</span> no core dump files are created.  When nonzero, larger dumps  are  truncated  to <span class="keyword">this</span> <span class="built_in">size</span>.</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2020/08/08/Linux/Linux_coredump/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/08/Linux/Linux_coredump/" data-id="ckxmr9pc60001287c0pz37boj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/10/computer-system/gcc-compile/">操作系统：hello world 编译过程</a>
          </li>
        
          <li>
            <a href="/2021/08/02/Linux/Linux_capabilities/">Linux 如何使用capabilities机制实现进程权限管理</a>
          </li>
        
          <li>
            <a href="/2020/10/14/algorithm/sort/">【算法】常见排序算法分析</a>
          </li>
        
          <li>
            <a href="/2020/08/08/Linux/Linux_coredump/">Linux coredump机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 ink<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>